#!/usr/bin/env python3
"""
Inference demo: predict structure for a given protein sequence.

Usage:
    python examples/inference_demo.py --sequence ACDEFGHIKLMNPQRSTVWY --checkpoint checkpoints/best_model.pt
"""

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

import torch
import argparse
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

from hqpf.models.hybrid_model import HybridModel


def parse_args():
    parser = argparse.ArgumentParser(description='Predict protein structure')
    parser.add_argument('--sequence', type=str, required=True, help='Protein sequence (one-letter code)')
    parser.add_argument('--checkpoint', type=str, required=True, help='Model checkpoint path')
    parser.add_argument('--n_candidates', type=int, default=20, help='Number of candidate structures')
    parser.add_argument('--device', type=str, default='cuda' if torch.cuda.is_available() else 'cpu')
    parser.add_argument('--output', type=str, default=None, help='Output file for structure (PDB or PNG)')
    return parser.parse_args()


def sequence_to_tensor(sequence: str) -> torch.Tensor:
    """Convert sequence string to tensor."""
    aa_to_idx = {
        'A': 0, 'R': 1, 'N': 2, 'D': 3, 'C': 4,
        'Q': 5, 'E': 6, 'G': 7, 'H': 8, 'I': 9,
        'L': 10, 'K': 11, 'M': 12, 'F': 13, 'P': 14,
        'S': 15, 'T': 16, 'W': 17, 'Y': 18, 'V': 19
    }
    
    indices = [aa_to_idx[aa] for aa in sequence.upper()]
    return torch.tensor(indices, dtype=torch.long)


def visualize_structure(structure: torch.Tensor, sequence: str, output_path: str = None):
    """Visualize 3D structure."""
    coords = structure.cpu().numpy()
    
    fig = plt.figure(figsize=(10, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Plot backbone trace
    ax.plot(coords[:, 0], coords[:, 1], coords[:, 2], 'b-', linewidth=2, alpha=0.7)
    
    # Plot residues as spheres
    ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], c=range(len(coords)), cmap='viridis', s=100)
    
    # Labels
    ax.set_xlabel('X (\u00c5)')
    ax.set_ylabel('Y (\u00c5)')
    ax.set_zlabel('Z (\u00c5)')
    ax.set_title(f'Predicted Structure: {sequence[:20]}...' if len(sequence) > 20 else f'Predicted Structure: {sequence}')
    
    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')
        print(f"Structure saved to {output_path}")
    else:
        plt.show()


def save_pdb(structure: torch.Tensor, sequence: str, output_path: str):
    """Save structure in PDB format."""
    coords = structure.cpu().numpy()
    
    with open(output_path, 'w') as f:
        f.write("REMARK   Generated by Hybrid Quantum-Classical Protein Folding\n")
        f.write(f"REMARK   Sequence: {sequence}\n")
        
        for i, (aa, coord) in enumerate(zip(sequence, coords)):
            f.write(
                f"ATOM  {i+1:5d}  CA  {aa:3s} A{i+1:4d}    "
                f"{coord[0]:8.3f}{coord[1]:8.3f}{coord[2]:8.3f}"
                f"  1.00  0.00           C\n"
            )
        
        f.write("END\n")
    
    print(f"PDB file saved to {output_path}")


def main():
    args = parse_args()
    
    print("=" * 80)
    print("Hybrid Quantum-Classical Protein Folding - Inference")
    print("=" * 80)
    print(f"Sequence: {args.sequence}")
    print(f"Length: {len(args.sequence)}")
    print(f"Device: {args.device}")
    print()
    
    # Load model
    print("Loading model...")
    checkpoint = torch.load(args.checkpoint, map_location=args.device)
    
    model = HybridModel(
        n_residues=len(args.sequence),
        n_qubits=20,
        embedding_dim=128,
        hidden_dim=256,
        use_quantum=False,  # Use surrogate for inference
        device=args.device
    )
    
    model.load_state_dict(checkpoint['model_state'])
    model.eval()
    
    print("Model loaded successfully.")
    print()
    
    # Predict structure
    print(f"Generating {args.n_candidates} candidate structures...")
    sequence_tensor = sequence_to_tensor(args.sequence).to(args.device)
    
    with torch.no_grad():
        outputs = model(
            sequence_tensor,
            n_candidates=args.n_candidates,
            use_surrogate=True,
            temperature=1.0
        )
    
    # Extract results
    best_structure = outputs['best_structure']
    best_energy = outputs['best_energy']
    
    print("Prediction completed!")
    print(f"Best energy: {best_energy.item():.4f}")
    print(f"Quantum hardware usage: {outputs['quantum_fraction']*100:.1f}%")
    print()
    
    # Save/visualize results
    if args.output:
        if args.output.endswith('.pdb'):
            save_pdb(best_structure, args.sequence, args.output)
        elif args.output.endswith('.png'):
            visualize_structure(best_structure, args.sequence, args.output)
        else:
            print(f"Unknown output format: {args.output}")
    else:
        print("Visualizing structure...")
        visualize_structure(best_structure, args.sequence)
    
    # Print summary statistics
    coords = best_structure.cpu().numpy()
    center = coords.mean(axis=0)
    rg = np.sqrt(np.mean(np.sum((coords - center) ** 2, axis=1)))
    
    print("Structure statistics:")
    print(f"  Radius of gyration: {rg:.2f} \u00c5")
    print(f"  Center of mass: ({center[0]:.2f}, {center[1]:.2f}, {center[2]:.2f})")
    print(f"  Bounding box: X=[{coords[:, 0].min():.2f}, {coords[:, 0].max():.2f}], "
          f"Y=[{coords[:, 1].min():.2f}, {coords[:, 1].max():.2f}], "
          f"Z=[{coords[:, 2].min():.2f}, {coords[:, 2].max():.2f}]")
    print()
    print("Done!")


if __name__ == '__main__':
    main()
